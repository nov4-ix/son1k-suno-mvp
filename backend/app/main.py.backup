
# from fastapi import FastAPI

from fastapi.middleware.cors import CORSMiddleware

from fastapi.staticfiles import StaticFiles

from fastapi.responses import FileResponse

from .settings import settings

from .db import init_db, SessionLocal

from .models import Song

from .queue import enqueue_song_processing

from .ws import manager

from pydantic import BaseModel

from typing import Optional

import uuid

app = FastAPI(title=settings.PROJECT_NAME)

# CORS middleware

app.add_middleware(

    CORSMiddleware,

    allow_origins=settings.CORS_ORIGINS.split(","),

    allow_credentials=True,

    allow_methods=["*"],

    allow_headers=["*"],

)

# Models for API

class SongCreate(BaseModel):

    title: str

    prompt: str

class WebhookResult(BaseModel):

    id: str

    status: str

    audio_url: Optional[str] = None

    metadata: Optional[dict] = None

class SunoGenerateRequest(BaseModel):

    prompt: str

    expresividad: float = 1.0

    produccion: float = 1.0

    creatividad: float = 1.0

# Startup event

@app.on_event("startup")

def on_start():

    init_db()

# API Routes

@app.get(f"{settings.API_PREFIX}/health")

def health():

    return {"status": "ok", "service": settings.PROJECT_NAME}

@app.post(f"{settings.API_PREFIX}/songs")

def create_song(song: SongCreate):

    job_id = str(uuid.uuid4())

    # TODO: persist in DB, trigger Suno generation

    enqueue_song_processing(song.prompt, job_id)

    return {"job_id": job_id, "status": "queued"}

@app.get(f"{settings.API_PREFIX}/songs/status/{job_id}")

def status(job_id: str):

    return {"job_id": job_id, "status": "queued"}  # TODO: real status

@app.post(f"{settings.API_PREFIX}/suno/generate")

def suno_generate(request: SunoGenerateRequest):

    """Generate music using Suno AI with creative controls"""

    try:

        job_id = str(uuid.uuid4())

        

        # Enhanced prompt with creative parameters

        enhanced_prompt = f"{request.prompt} [expresividad:{request.expresividad}] [produccion:{request.produccion}] [creatividad:{request.creatividad}]"

        

        # TODO: Implement actual Suno API call

        # For now, return a mock response

        return {

            "success": True,

            "job_id": job_id,

            "message": "Generación iniciada con Suno AI",

            "status": "processing",

            "estimated_time": "30-60 seconds",

            "audio_url": None  # Will be populated when generation completes

        }

    except Exception as e:

        return {

            "success": False,

            "error": f"Error en generación: {str(e)}"

        }

@app.post(f"{settings.API_PREFIX}/suno/results")

def suno_results(r: WebhookResult):

    # TODO: persist in DB, create Song/Asset rows, trigger process_audio

    print("SUNO RESULT:", r.dict())

    return {"ok": True}

# Frontend serving

app.mount("/static", StaticFiles(directory="frontend"), name="static")

@app.get("/")

async def read_index():

    return FileResponse('frontend/index.html')

@app.get("/favicon.ico")

async def favicon():

    return FileResponse('frontend/favicon.ico')

# WebSocket endpoint for real-time updates

@app.websocket("/ws")

async def websocket_endpoint(websocket):

    await manager.connect(websocket)

    try:

        while True:

            data = await websocket.receive_text()

            await manager.send_personal_message(f"Echo: {data}", websocket)

    except Exception as e:

        print(f"WebSocket error: {e}")

    finally:

        manager.disconnect(websocket)

